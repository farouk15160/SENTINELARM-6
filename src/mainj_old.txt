/**
 * @file main.cpp
 * @brief Fully interruptible, non-blocking firmware for ROS2 Robot Arm with auto-calibration and optimizations
 * @author Farouk
 * @date 25 Oct 2025
 *
 * @description
 * This firmware uses a non-blocking, dual-task architecture for motion control.
 *
 * Version 3.8.1 (A-RGB E-Stop Integration):
 * - Integrated FastLED library for A-RGB fan control.
 * - emergency_stop() now IMMEDIATELY sets LEDs to solid RED for instant safety feedback.
 * - task_monitoring() maintains LED state: solid RED during E-Stop, rainbow "glow" during normal operation.
 * - Added new command 'E': Releases E-Stop. Resets collision flag, resumes suspended
 * tasks (motion and parser), and re-enables motor power.
 * - `emergency_stop()` is now safer and won't try to suspend null tasks.
 * - Added EEPROM persistence for Min/Max limits and collision threshold.
 * - `StatusPacket` now has a `cmd_id` of 'S' (0x53) for multi-packet parsing.
 */

#include <Wire.h>
#include <Adafruit_PWMServoDriver.h>
#include <Adafruit_INA219.h>
#include <EEPROM.h>
#include <cmath>
#include <FastLED.h> // --- NEW: Added FastLED library ---

// --- Stepper Motor (Base) Configuration ---
const int STEPPER_DIR_PIN = 16;
const int STEPPER_STEP_PIN = 17;
const int STEPPER_MS1_PIN = 18;
const int STEPPER_MS2_PIN = 19;
const int STEPPER_MS3_PIN = 23;
const int STEPPER_ENABLE_PIN = 4;

#define STEPPER_STEPS_PER_REV 200
#define STEPPER_MICROSTEPS 16
#define STEPPER_GEAR_RATIO 5.0f
#define STEPPER_PULSE_WIDTH_US 10 // old 50
#define STEPPER_PULSE_DELAY_US 500

const float STEPPER_STEPS_PER_DEGREE = (STEPPER_STEPS_PER_REV * STEPPER_MICROSTEPS * STEPPER_GEAR_RATIO) / 360.0f;

// --- NEW: A-RGB LED Configuration ---
#define RGB_DATA_PIN 25        // <<<--- IMPORTANT: Set this to your ESP32 data pin
#define RGB_NUM_LEDS 12        // Your fan has 12 LEDs
#define FAN_RGB_BRIGHTNESS 100 // Brightness (0-255) // <-- RENAMED from RGB_BRIGHTNESS
#define RGB_LED_TYPE WS2812B
// --- MODIFIED: Changed color order. White LEDs often mean the order is wrong.
// If this doesn't work, try other orders like BRG, RBG, GBR, etc.
#define RGB_COLOR_ORDER RGB // Was GRB
CRGB g_leds[RGB_NUM_LEDS];  // Global array for LEDs

// ==========================================================================
// --- Multi-Tasking & Safety Configuration ---
// ==========================================================================
TaskHandle_t h_task_command_parser = NULL;
TaskHandle_t h_task_monitoring = NULL;
TaskHandle_t h_task_motion_interpolator = NULL;
SemaphoreHandle_t x_pose_mutex;

volatile float g_collision_current_threshold_A = 5.0f;
volatile bool g_collisionDetected = false;
volatile float g_mainCurrent_A = 0.0;
volatile float g_gripperCurrent_mA = 0.0;
float g_calibrated_zero_voltage = 2.3914f;

// --- Motion Control State (Protected by Mutex) ---
float g_current_angles[6];
float g_target_angles[6];
unsigned long g_move_start_time;
unsigned long g_move_duration_ms;
volatile float g_grip_target_current_mA = -1.0f;
volatile long g_stepper_current_step_pos = 0;

// ==========================================================================
// --- Hardware & Servo Configuration ---
// ==========================================================================
#define ACS712_PIN 34
#define OE_PIN 13
#define BAUD_RATE 921600
#define PWM_FREQ 50
#define GRIPPER_SERVO_INDEX 5
#define JOINT_1_SECOND_SERVO 11
#define SERVOS_NUMBER 6
#define SERVO_MIN_US 500
#define SERVO_MAX_US 2500

Adafruit_INA219 ina219 = Adafruit_INA219(0x41);
Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(0x40);

const uint8_t SERVOS[SERVOS_NUMBER] = {0, 10, 12, 13, 14, 15};
float SERVOS_MIN[SERVOS_NUMBER] = {15.0f, 40.0f, 0.0f, 30.0f, 0.0f, 0.0f};
float SERVOS_MAX[SERVOS_NUMBER] = {345.0f, 150.0f, 145.0f, 130.0f, 180.0f, 120.0f};

const float HOME_POSITION[SERVOS_NUMBER] = {133.0f, 100.00, 110.00, 130.00, 15.00, 60.00};
const bool SERVO_INVERT[SERVOS_NUMBER] = {false, true, false, false, false, false};
const int16_t TRIM_US[SERVOS_NUMBER] = {0, 0, 0, 0, 0, 0};

// ==========================================================================
// --- EEPROM Configuration ---
// ==========================================================================
#define EEPROM_SIZE 128
#define EEPROM_VALID_FLAG 123
#define EEPROM_VALID_FLAG_ADDR 0
#define EEPROM_POSE_ADDR 1
#define EEPROM_CONFIG_ADDR (EEPROM_POSE_ADDR + sizeof(float) * SERVOS_NUMBER)

struct ArmConfig
{
  float min_limits[SERVOS_NUMBER];
  float max_limits[SERVOS_NUMBER];
  float collision_threshold;
};

// ==========================================================================
// --- Binary Communication Protocol ---
// ==========================================================================
#define HEADER_BYTE 0xA5
#pragma pack(push, 1)
struct CommandPacket
{
  uint8_t header;
  uint8_t cmd_id;
  float angles[6];
  float speed_factor;
  float gripper_current_ma;
  uint8_t checksum;
};
struct StatusPacket
{
  uint8_t header;
  uint8_t cmd_id;
  float main_current_A;
  float gripper_current_mA;
  float angles[6];
  uint8_t checksum;
};
struct ConfigPacket
{
  uint8_t header;
  uint8_t cmd_id;
  float min_limits[6];
  float max_limits[6];
  float collision_threshold;
  uint8_t checksum;
};
#pragma pack(pop)

// --- Helper Functions ---
uint8_t calculate_checksum(const uint8_t *data, size_t len)
{
  uint8_t checksum = 0;
  for (size_t i = 0; i < len; ++i)
  {
    checksum ^= data[i];
  }
  return checksum;
}

int angleToPulse(float degrees, int servo_index)
{
  xSemaphoreTake(x_pose_mutex, portMAX_DELAY);
  float min_angle = SERVOS_MIN[servo_index];
  float max_angle = SERVOS_MAX[servo_index];
  xSemaphoreGive(x_pose_mutex);

  float safe_angle = constrain(degrees, min_angle, max_angle);
  if (SERVO_INVERT[servo_index])
  {
    safe_angle = 180.0f - safe_angle;
  }
  int pulse = map(safe_angle, 0, 180, SERVO_MIN_US, SERVO_MAX_US);
  return pulse + TRIM_US[servo_index];
}

static inline float easeInOutCubic(float t)
{
  t *= 2.0f;
  if (t < 1.0f)
    return 0.5f * t * t * t;
  t -= 2.0f;
  return 0.5f * (t * t * t + 2.0f);
}

// ==========================================================================
// --- SAFETY FUNCTION ---
// ==========================================================================
void emergency_stop()
{
  g_collisionDetected = true;
  digitalWrite(OE_PIN, HIGH);
  digitalWrite(STEPPER_ENABLE_PIN, HIGH);
  Serial.println("\nE-STOP: Main current limit exceeded. Halting.\n");

  // --- NEW: Set LEDs to RED IMMEDIATELY ---
  // We do this here for minimum latency.
  // task_monitoring will keep them red on its next loop.
  fill_solid(g_leds, RGB_NUM_LEDS, CRGB::Red);
  FastLED.show();
  // --- END NEW ---

  // --- MODIFIED: Check task handles are valid before suspending ---
  if (h_task_motion_interpolator != NULL)
    vTaskSuspend(h_task_motion_interpolator);
  if (h_task_command_parser != NULL)
    vTaskSuspend(h_task_command_parser);
}

// ==========================================================================
// --- Motion Interpolator Task (Core 1, High Priority) ---
// ==========================================================================
void task_motion_interpolator(void *pvParameters)
{
  const TickType_t xFrequency = pdMS_TO_TICKS(20); // 50 Hz
  TickType_t xLastWakeTime = xTaskGetTickCount();
  for (;;)
  {
    vTaskDelayUntil(&xLastWakeTime, xFrequency);
    if (g_collisionDetected)
      continue;

    xSemaphoreTake(x_pose_mutex, portMAX_DELAY);

    unsigned long elapsed_time = millis() - g_move_start_time;
    float fraction = (g_move_duration_ms > 0) ? (float)elapsed_time / (float)g_move_duration_ms : 1.0f;
    fraction = constrain(fraction, 0.0f, 1.0f);
    float eased_fraction = easeInOutCubic(fraction);

    if (g_grip_target_current_mA > 0 && fabsf(g_gripperCurrent_mA) > g_grip_target_current_mA)
    {
      float final_grip_angle = (g_current_angles[GRIPPER_SERVO_INDEX] * (1.0f - eased_fraction)) + (g_target_angles[GRIPPER_SERVO_INDEX] * eased_fraction);
      g_current_angles[GRIPPER_SERVO_INDEX] = final_grip_angle;
      g_target_angles[GRIPPER_SERVO_INDEX] = final_grip_angle;
      g_grip_target_current_mA = -1.0f;
    }

    long start_step_pos = (long)(g_current_angles[0] * STEPPER_STEPS_PER_DEGREE);
    long end_step_pos = (long)(g_target_angles[0] * STEPPER_STEPS_PER_DEGREE);
    long total_steps_for_move = end_step_pos - start_step_pos;
    long current_target_step_pos = start_step_pos + (long)(total_steps_for_move * eased_fraction);
    long steps_to_move = current_target_step_pos - g_stepper_current_step_pos;

    if (steps_to_move != 0)
    {
      digitalWrite(STEPPER_DIR_PIN, (steps_to_move > 0) ? (SERVO_INVERT[0] ? HIGH : LOW) : (SERVO_INVERT[0] ? LOW : HIGH));
      long num_steps_to_pulse = abs(steps_to_move);
      for (long i = 0; i < num_steps_to_pulse; i++)
      {
        digitalWrite(STEPPER_STEP_PIN, HIGH);
        delayMicroseconds(STEPPER_PULSE_WIDTH_US);
        digitalWrite(STEPPER_STEP_PIN, LOW);
        delayMicroseconds(STEPPER_PULSE_DELAY_US);
      }
      g_stepper_current_step_pos = current_target_step_pos;
    }

    for (int i = 1; i < SERVOS_NUMBER; i++)
    {
      float interpolated_angle = (g_current_angles[i] * (1.0f - eased_fraction)) + (g_target_angles[i] * eased_fraction);

      xSemaphoreGive(x_pose_mutex);
      int pulse = angleToPulse(interpolated_angle, i);
      xSemaphoreTake(x_pose_mutex, portMAX_DELAY);

      pwm.writeMicroseconds(SERVOS[i], pulse);
      if (i == 1)
      {
        pwm.writeMicroseconds(JOINT_1_SECOND_SERVO, pulse);
      }
    }

    if (fraction >= 1.0f)
    {
      g_grip_target_current_mA = -1.0;
      for (int i = 0; i < SERVOS_NUMBER; i++)
      {
        g_current_angles[i] = g_target_angles[i];
      }
      g_stepper_current_step_pos = end_step_pos;
    }
    xSemaphoreGive(x_pose_mutex);
  }
}

// ==========================================================================
// --- Command Parser Task (Core 1, Low Priority) ---
// ==========================================================================
void parse_command(const CommandPacket &cmd)
{
  // --- MODIFIED: Allow 'E' command even if collision was detected ---
  if (g_collisionDetected && cmd.cmd_id != 'E')
    return;

  switch (cmd.cmd_id)
  {
  case 'M':
  case 'H':
  case 'G':
  {
    xSemaphoreTake(x_pose_mutex, portMAX_DELAY);
    if (cmd.cmd_id == 'M' || cmd.cmd_id == 'H')
    {
      g_grip_target_current_mA = -1.0f;
    }
    unsigned long elapsed_time = millis() - g_move_start_time;
    float fraction = g_move_duration_ms > 0 ? (float)elapsed_time / (float)g_move_duration_ms : 1.0f;
    fraction = constrain(fraction, 0.0f, 1.0f);
    float eased_fraction = easeInOutCubic(fraction);
    for (int i = 0; i < SERVOS_NUMBER; i++)
    {
      g_current_angles[i] = (g_current_angles[i] * (1.0f - eased_fraction)) + (g_target_angles[i] * eased_fraction);
    }
    g_stepper_current_step_pos = (long)(g_current_angles[0] * STEPPER_STEPS_PER_DEGREE);

    float max_angle_delta = 0.0f;
    for (int i = 0; i < SERVOS_NUMBER; i++)
    {
      float target = (cmd.cmd_id == 'H') ? HOME_POSITION[i] : cmd.angles[i];
      g_target_angles[i] = constrain(target, SERVOS_MIN[i], SERVOS_MAX[i]);
      float delta = std::abs(g_target_angles[i] - g_current_angles[i]);
      if (delta > max_angle_delta)
      {
        max_angle_delta = delta;
      }
    }

    if (cmd.cmd_id == 'G')
    {
      g_grip_target_current_mA = cmd.gripper_current_ma;
    }

    g_move_start_time = millis();
    float speed = (cmd.speed_factor > 0.01f) ? cmd.speed_factor : 10.0f;
    g_move_duration_ms = max_angle_delta * speed;
    if (cmd.cmd_id == 'H')
      g_move_duration_ms = 3000;
    xSemaphoreGive(x_pose_mutex);
    break;
  }
  case 'S':
  {
    xSemaphoreTake(x_pose_mutex, portMAX_DELAY);
    unsigned long elapsed_time = millis() - g_move_start_time;
    float fraction = g_move_duration_ms > 0 ? (float)elapsed_time / (float)g_move_duration_ms : 1.0f;
    fraction = constrain(fraction, 0.0f, 1.0f);
    float eased_fraction = easeInOutCubic(fraction);
    float angles_to_save[SERVOS_NUMBER];
    for (int i = 0; i < SERVOS_NUMBER; i++)
    {
      angles_to_save[i] = (g_current_angles[i] * (1.0f - eased_fraction)) + (g_target_angles[i] * eased_fraction);
    }
    EEPROM.write(EEPROM_VALID_FLAG_ADDR, EEPROM_VALID_FLAG);
    EEPROM.put(EEPROM_POSE_ADDR, angles_to_save);
    EEPROM.commit();
    xSemaphoreGive(x_pose_mutex);
    Serial.println("INFO: Current pose saved to EEPROM.");
    break;
  }
  case 'N':
  {
    xSemaphoreTake(x_pose_mutex, portMAX_DELAY);
    for (int i = 0; i < SERVOS_NUMBER; i++)
    {
      if (cmd.angles[i] < SERVOS_MAX[i])
      {
        SERVOS_MIN[i] = cmd.angles[i];
      }
    }
    xSemaphoreGive(x_pose_mutex);
    Serial.println("INFO: SERVOS_MIN limits updated in RAM.");
    break;
  }
  case 'X':
  {
    xSemaphoreTake(x_pose_mutex, portMAX_DELAY);
    for (int i = 0; i < SERVOS_NUMBER; i++)
    {
      if (cmd.angles[i] > SERVOS_MIN[i])
      {
        SERVOS_MAX[i] = cmd.angles[i];
      }
    }
    xSemaphoreGive(x_pose_mutex);
    Serial.println("INFO: SERVOS_MAX limits updated in RAM.");
    break;
  }
  case 'T':
  {
    float new_threshold = cmd.speed_factor;
    if (new_threshold > 0.1f && new_threshold < 20.0f)
    {
      g_collision_current_threshold_A = new_threshold;
      Serial.print("INFO: Main current threshold set to: ");
      Serial.println(g_collision_current_threshold_A);
    }
    break;
  }
  case 'C':
  {
    xSemaphoreTake(x_pose_mutex, portMAX_DELAY);
    ArmConfig cfg;
    memcpy(cfg.min_limits, (void *)SERVOS_MIN, sizeof(SERVOS_MIN));
    memcpy(cfg.max_limits, (void *)SERVOS_MAX, sizeof(SERVOS_MAX));
    cfg.collision_threshold = g_collision_current_threshold_A;

    EEPROM.put(EEPROM_CONFIG_ADDR, cfg);
    EEPROM.write(EEPROM_VALID_FLAG_ADDR, EEPROM_VALID_FLAG);
    EEPROM.commit();

    xSemaphoreGive(x_pose_mutex);
    Serial.println("INFO: Configuration saved to EEPROM.");
    break;
  }
  case 'R':
  {
    ConfigPacket packet;
    packet.header = HEADER_BYTE;
    packet.cmd_id = 'R';

    xSemaphoreTake(x_pose_mutex, portMAX_DELAY);
    memcpy(packet.min_limits, (void *)SERVOS_MIN, sizeof(SERVOS_MIN));
    memcpy(packet.max_limits, (void *)SERVOS_MAX, sizeof(SERVOS_MAX));
    packet.collision_threshold = g_collision_current_threshold_A;
    xSemaphoreGive(x_pose_mutex);

    packet.checksum = calculate_checksum((uint8_t *)&packet, sizeof(ConfigPacket) - 1);
    Serial.write((uint8_t *)&packet, sizeof(ConfigPacket));
    Serial.println("INFO: Sent config report.");
    break;
  }
  // --- NEW: E-Stop Release Command ---
  case 'E':
  {
    Serial.println("INFO: E-Stop Release command received.");
    g_collisionDetected = false;
    // --- NOTE: LEDs will be updated by task_monitoring on its next cycle ---

    // Resume tasks if they were suspended
    if (h_task_motion_interpolator != NULL)
      vTaskResume(h_task_motion_interpolator);
    if (h_task_command_parser != NULL)
      vTaskResume(h_task_command_parser);

    // Re-enable motors
    digitalWrite(STEPPER_ENABLE_PIN, LOW);
    digitalWrite(OE_PIN, LOW);
    Serial.println("INFO: Tasks resumed and motors re-enabled.");
    break;
  }
  } // end switch
}

// ... (task_command_parser is unchanged) ...
void task_command_parser(void *pvParameters)
{
  uint8_t serial_buffer[sizeof(CommandPacket)];
  int buffer_pos = 0;
  for (;;)
  {
    while (Serial.available() > 0)
    {
      uint8_t byte_in = Serial.read();
      if (buffer_pos == 0)
      {
        if (byte_in == HEADER_BYTE)
        {
          serial_buffer[buffer_pos++] = byte_in;
        }
      }
      else
      {
        serial_buffer[buffer_pos++] = byte_in;
        if (buffer_pos >= sizeof(CommandPacket))
        {
          CommandPacket received_cmd;
          memcpy(&received_cmd, serial_buffer, sizeof(CommandPacket));
          uint8_t calculated_cs = calculate_checksum(serial_buffer, sizeof(CommandPacket) - 1);
          if (calculated_cs == received_cmd.checksum)
          {
            parse_command(received_cmd);
          }
          else
          {
            Serial.println("WARN: Checksum failed!");
          }
          buffer_pos = 0;
        }
      }
    }
    vTaskDelay(pdMS_TO_TICKS(5));
  }
}

// ==========================================================================
// --- Monitoring & LED Task (Core 0, Low Priority) ---
// ... (task_monitoring is unchanged) ...
void task_monitoring(void *pvParameters)
{
  long lastStatusSendTime = 0;
  const int nSamples = 250;
  const float sens = 0.066;
  const float vcc = 3.3;
  const int adcMax = 4095;

  static uint8_t gHue = 0; // For rainbow effect

  for (;;)
  {
    // --- 1. Read sensors ---
    long val = 0;
    for (int i = 0; i < nSamples; i++)
      val += analogRead(ACS712_PIN);
    float measured_voltage = ((float)val / nSamples / adcMax) * vcc;
    g_mainCurrent_A = (measured_voltage - g_calibrated_zero_voltage) / sens;
    g_gripperCurrent_mA = ina219.getCurrent_mA();

    // --- 2. Check for E-Stop condition ---
    if (fabsf(g_mainCurrent_A) > g_collision_current_threshold_A)
    {
      // This function sets g_collisionDetected = true
      // and immediately sets LEDs to RED.
      emergency_stop();
    }

    // --- 3. Update LED Status based on E-Stop flag ---
    if (g_collisionDetected)
    {
      // E-Stop is active: Maintain solid RED
      fill_solid(g_leds, RGB_NUM_LEDS, CRGB::Red);
    }
    else
    {
      // Normal operation: Run "glowing" rainbow
      fill_rainbow(g_leds, RGB_NUM_LEDS, gHue, 7);
      gHue++; // Increment hue to make the rainbow move
    }

    // Show the updated LED state (handles both E-Stop and Normal)
    FastLED.show();

    // --- 4. Send Status Packet (only if NOT in E-Stop) ---
    if (millis() - lastStatusSendTime > 100 && !g_collisionDetected)
    {
      StatusPacket status;
      status.header = HEADER_BYTE;
      status.cmd_id = 'S';
      status.main_current_A = g_mainCurrent_A;
      status.gripper_current_mA = g_gripperCurrent_mA;

      xSemaphoreTake(x_pose_mutex, portMAX_DELAY);
      unsigned long elapsed_time = millis() - g_move_start_time;
      float fraction = g_move_duration_ms > 0 ? (float)elapsed_time / (float)g_move_duration_ms : 1.0f;
      fraction = constrain(fraction, 0.0f, 1.0f);
      float eased_fraction = easeInOutCubic(fraction);
      for (int i = 0; i < SERVOS_NUMBER; i++)
      {
        status.angles[i] = (g_current_angles[i] * (1.0f - eased_fraction)) + (g_target_angles[i] * eased_fraction);
      }
      xSemaphoreGive(x_pose_mutex);

      status.checksum = calculate_checksum((uint8_t *)&status, sizeof(StatusPacket) - 1);
      Serial.write((uint8_t *)&status, sizeof(StatusPacket));
      lastStatusSendTime = millis();
    }

    // --- 5. Delay until next cycle ---
    vTaskDelay(pdMS_TO_TICKS(50)); // Runs at ~20 Hz
  }
}

// ... (setup and loop are unchanged) ...
void setup()
{
  // --- Step 1: Disable all motors IMMEDIATELY ---
  pinMode(OE_PIN, OUTPUT);
  digitalWrite(OE_PIN, HIGH);
  pinMode(STEPPER_ENABLE_PIN, OUTPUT);
  digitalWrite(STEPPER_ENABLE_PIN, HIGH);

  delay(2000);

  Serial.begin(BAUD_RATE);
  Serial.println("\n--- ESP32 Robot Arm Firmware (v3.8.1 A-RGB E-Stop) ---");
  EEPROM.begin(EEPROM_SIZE);

  // --- Step 2: Initialize Stepper Pins ---
  pinMode(STEPPER_DIR_PIN, OUTPUT);
  pinMode(STEPPER_STEP_PIN, OUTPUT);
  pinMode(STEPPER_MS1_PIN, OUTPUT);
  pinMode(STEPPER_MS2_PIN, OUTPUT);
  pinMode(STEPPER_MS3_PIN, OUTPUT);
  digitalWrite(STEPPER_MS1_PIN, HIGH);
  digitalWrite(STEPPER_MS2_PIN, HIGH);
  digitalWrite(STEPPER_MS3_PIN, HIGH);

  // --- Step 3: Initialize I2C Devices ---
  Wire.begin();
  pwm.begin();
  pwm.setOscillatorFrequency(27000000);
  pwm.setPWMFreq(PWM_FREQ);
  ina219.begin();

  // --- NEW: Initialize A-RGB LEDs ---
  Serial.println("INFO: Initializing A-RGB LEDs...");
  pinMode(RGB_DATA_PIN, OUTPUT);
  FastLED.addLeds<RGB_LED_TYPE, RGB_DATA_PIN, RGB_COLOR_ORDER>(g_leds, RGB_NUM_LEDS);
  FastLED.setBrightness(FAN_RGB_BRIGHTNESS);     // <-- USE RENAMED constant
  fill_solid(g_leds, RGB_NUM_LEDS, CRGB::Black); // Start with LEDs off
  FastLED.show();
  delay(100);
  // --- END NEW ---

  // --- Step 4: Calibrate Current Sensor ---
  // Serial.println("Calibrating current sensor...");
  // long adc_sum = 0;
  // const int n_cal_samples = 1000;
  // for (int i = 0; i < n_cal_samples; i++)
  // {
  //   adc_sum += analogRead(ACS712_PIN);
  //   delay(1);
  // }
  // g_calibrated_zero_voltage = ((float)adc_sum / n_cal_samples / 4095.0f) * 3.3f;
  // Serial.print("Calibration complete. Zero-point voltage: ");
  // Serial.println(g_calibrated_zero_voltage, 4);

  // --- Step 5: Load and Validate Startup Pose AND Config from EEPROM ---
  if (EEPROM.read(EEPROM_VALID_FLAG_ADDR) == EEPROM_VALID_FLAG)
  {
    Serial.println("INFO: Restoring pose and config from EEPROM.");
    float temp_angles[SERVOS_NUMBER];
    EEPROM.get(EEPROM_POSE_ADDR, temp_angles);

    ArmConfig cfg;
    EEPROM.get(EEPROM_CONFIG_ADDR, cfg);
    memcpy(SERVOS_MIN, cfg.min_limits, sizeof(SERVOS_MIN));
    memcpy(SERVOS_MAX, cfg.max_limits, sizeof(SERVOS_MAX));
    g_collision_current_threshold_A = cfg.collision_threshold;

    for (int i = 0; i < SERVOS_NUMBER; i++)
    {
      g_current_angles[i] = constrain(temp_angles[i], SERVOS_MIN[i], SERVOS_MAX[i]);
      g_target_angles[i] = g_current_angles[i];
    }
  }
  else
  {
    Serial.println("INFO: No valid config. Saving defaults to EEPROM.");
    for (int i = 0; i < SERVOS_NUMBER; i++)
    {
      g_current_angles[i] = constrain(HOME_POSITION[i], SERVOS_MIN[i], SERVOS_MAX[i]);
      g_target_angles[i] = g_current_angles[i];
    }

    EEPROM.put(EEPROM_POSE_ADDR, g_current_angles);

    ArmConfig cfg;
    memcpy(cfg.min_limits, (void *)SERVOS_MIN, sizeof(SERVOS_MIN));
    memcpy(cfg.max_limits, (void *)SERVOS_MAX, sizeof(SERVOS_MAX));
    cfg.collision_threshold = g_collision_current_threshold_A;
    EEPROM.put(EEPROM_CONFIG_ADDR, cfg);

    EEPROM.write(EEPROM_VALID_FLAG_ADDR, EEPROM_VALID_FLAG);
    EEPROM.commit();
  }
  Serial.println("INFO: Config loaded:");
  Serial.print("  Threshold: ");
  Serial.println(g_collision_current_threshold_A);

  // --- Step 6: Initialize Global Motion State ---
  g_stepper_current_step_pos = (long)(g_current_angles[0] * STEPPER_STEPS_PER_DEGREE);
  g_move_start_time = millis();
  g_move_duration_ms = 0;

  // --- Step 7: Create Mutex ---
  x_pose_mutex = xSemaphoreCreateMutex();
  if (x_pose_mutex == NULL)
  {
    Serial.println("FATAL: Could not create pose mutex. Halting.");
    fill_solid(g_leds, RGB_NUM_LEDS, CRGB::Red); // Show error
    FastLED.show();
    while (1)
      ;
  }

  // --- Step 8: Pre-load servos ---
  Serial.println("INFO: Pre-loading servo positions...");
  for (int i = 1; i < SERVOS_NUMBER; i++)
  {
    int pulse = angleToPulse(g_current_angles[i], i);
    pwm.writeMicroseconds(SERVOS[i], pulse);
    if (i == 1)
    {
      pwm.writeMicroseconds(JOINT_1_SECOND_SERVO, pulse);
    }
  }
  delay(500);

  // --- Step 9: Enable all motors ---
  digitalWrite(STEPPER_ENABLE_PIN, LOW);
  digitalWrite(OE_PIN, LOW);
  Serial.println("Motors enabled. Startup should be smooth.");

  // --- Step 10: Start Tasks ---
  Serial.println("Initializing tasks...");
  xTaskCreatePinnedToCore(task_monitoring, "Monitoring", 4096, NULL, 1, &h_task_monitoring, 0);
  xTaskCreatePinnedToCore(task_command_parser, "CmdParser", 4096, NULL, 2, &h_task_command_parser, 1);
  xTaskCreatePinnedToCore(task_motion_interpolator, "Motion", 4096, NULL, 3, &h_task_motion_interpolator, 1);
  Serial.println("Initialization Complete. Ready for commands.");
}

void loop()
{
  // The FreeRTOS scheduler is running the tasks.
  // This loop should be empty or deleted.
  vTaskDelete(NULL);
}
