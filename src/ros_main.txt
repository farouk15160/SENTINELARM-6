#include <Arduino.h>
#include <Wire.h>
#include <Adafruit_PWMServoDriver.h>
#include <Adafruit_INA219.h>
#include <EEPROM.h>

#include <micro_ros_platformio.h>
#include <rcl/rcl.h>
#include <rclc/rclc.h>
#include <rclc/executor.h>

#include <sensor_msgs/msg/joint_state.h>
#include <std_msgs/msg/float32.h>
#include <std_srvs/srv/trigger.h>
#include <rosidl_runtime_c/string_functions.h>

// ==========================================================================
// --- Multi-Tasking & Safety Configuration ---
// ==========================================================================
TaskHandle_t h_task_robot_control = NULL;
TaskHandle_t h_task_monitoring = NULL;
SemaphoreHandle_t x_currentPulse_mutex;

volatile float g_collision_current_threshold_A = 2.5f;
volatile bool g_collisionDetected = false;
volatile float g_mainCurrent_A = 0.0;
volatile float g_gripperCurrent_mA = 0.0;

#define GRIPPER_AVG_SAMPLES 5
volatile float g_gripper_current_samples[GRIPPER_AVG_SAMPLES] = {0.0};
volatile int g_gripper_sample_idx = 0;

#define EEPROM_SIZE 128

// ==========================================================================
// --- ACS712 Main Power Current Sensor Configuration ---
// ==========================================================================
#define ACS712_PIN 34
const float sens = 0.66;
const float vcc = 3.3;
const int adcMax = 4095;
const int nSamples = 250;
float zero_point_voltage = 1.65;

// ==========================================================================
// --- SENSOR & HARDWARE OBJECTS ---
// ==========================================================================
Adafruit_INA219 ina219 = Adafruit_INA219(0x41);
Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(0x40);

// ==========================================================================
// --- Robot Arm Configuration ---
// ==========================================================================
#define OE_PIN 13
#define AUTO_HOME_ON_BOOT 1

#define SERVOS_NUMBER 6
#define SERVO_MIN_US 500
#define SERVO_MAX_US 2500
#define PWM_FREQ 50
#define GRIPPER_SERVO_INDEX 5

// This now acts as a default and can be changed via a ROS topic
volatile float g_speed_factor_ms_per_degree = 150.0f;
#define DURATION_MIN_MS 100
#define DURATION_MAX_MS 4000

const uint8_t SERVOS[SERVOS_NUMBER] = {10, 11, 12, 13, 14, 15};
const float SERVOS_MIN[SERVOS_NUMBER] = {40.0f, 40.0f, 0.0f, 30.0f, 0.0f, 20.0f};
const float SERVOS_MAX[SERVOS_NUMBER] = {150.0f, 150.0f, 145.0f, 130.0f, 120.0f, 93.0f};
const float HOME_POSITION[SERVOS_NUMBER] = {90.00, 90.00, 90.00, 90.00, 90.00, 30.00};
const bool SERVO_INVERT[SERVOS_NUMBER] = {true, false, false, false, false, false};
const int16_t TRIM_US[SERVOS_NUMBER] = {0, 0, 0, 0, 0, 0};

int currentPulse[16];

// ==========================================================================
// --- ROS2 Configuration ---
// ==========================================================================
rclc_executor_t executor;
rclc_support_t support;
rcl_allocator_t allocator;
rcl_node_t node;

// Publishers
rcl_publisher_t joint_state_publisher;
rcl_publisher_t main_current_publisher;
rcl_publisher_t gripper_current_publisher;
sensor_msgs__msg__JointState joint_state_msg;
std_msgs__msg__Float32 main_current_msg;
std_msgs__msg__Float32 gripper_current_msg;

// Subscribers
rcl_subscription_t joint_command_subscriber;
sensor_msgs__msg__JointState joint_command_msg;
// NEW: Subscribers for speed and collision
rcl_subscription_t speed_subscriber;
rcl_subscription_t collision_subscriber;
std_msgs__msg__Float32 speed_msg;
std_msgs__msg__Float32 collision_msg;

// Services
rcl_service_t home_service;
std_srvs__srv__Trigger_Request home_req;
std_srvs__srv__Trigger_Response home_res;

// Function Prototypes
void moveServosSmoothly(const uint8_t channels[], const float targetAngles[], uint8_t num_channels, uint32_t override_duration = 0);
void goHome(uint16_t duration);
void joint_command_callback(const void *msgin);
void home_service_callback(const void *req, void *res);
// NEW: Callbacks for new subscribers
void speed_callback(const void *msgin);
void collision_callback(const void *msgin);
void publish_telemetry();

// ==========================================================================
// --- Math & Conversion Helpers ---
// ==========================================================================
int angleToPulse(float degrees)
{
  return map(degrees, 0, 180, SERVO_MIN_US, SERVO_MAX_US);
}

float pulseToAngle(int pulse, int servoIndex)
{
  int pulseWithoutTrim = pulse - TRIM_US[servoIndex];
  float degrees = (float)(pulseWithoutTrim - SERVO_MIN_US) * 180.0f / (float)(SERVO_MAX_US - SERVO_MIN_US);
  return SERVO_INVERT[servoIndex] ? 180.0f - degrees : degrees;
}

static inline float easeInOutQuint(float t)
{
  if (t < 0.5f)
    return 16.0f * t * t * t * t * t;
  float f = t - 1.0f;
  return 1.0f + 16.0f * f * f * f * f * f;
}

// ==========================================================================
// --- SAFETY FUNCTION ---
// ==========================================================================
void emergency_stop()
{
  g_collisionDetected = true;
  digitalWrite(OE_PIN, HIGH); // Disable servo driver outputs
  Serial.println("\n\n!! E-STOP: Main current exceeded threshold !!");
}

// ==========================================================================
// --- Core Motion Functions ---
// ==========================================================================
void moveServosSmoothly(const uint8_t channels[], const float targetAngles[], uint8_t num_channels, uint32_t override_duration)
{
  if (g_collisionDetected)
    return;

  int startPulse[num_channels];
  int targetPulse[num_channels];
  int deltaPulse[num_channels];
  float max_angle_delta = 0.0f;

  xSemaphoreTake(x_currentPulse_mutex, portMAX_DELAY);
  for (int i = 0; i < num_channels; i++)
  {
    uint8_t ch = channels[i];
    int servo_idx = -1;
    for (int j = 0; j < SERVOS_NUMBER; j++)
      if (SERVOS[j] == ch)
        servo_idx = j;
    if (servo_idx == -1)
      continue;

    startPulse[i] = currentPulse[ch];
    float startAngle = pulseToAngle(startPulse[i], servo_idx);
    float angle_delta = abs(targetAngles[i] - startAngle);
    if (angle_delta > max_angle_delta)
    {
      max_angle_delta = angle_delta;
    }

    float safeAngle = constrain(targetAngles[i], SERVOS_MIN[servo_idx], SERVOS_MAX[servo_idx]);
    if (SERVO_INVERT[servo_idx])
      safeAngle = 180.0f - safeAngle;
    targetPulse[i] = angleToPulse(safeAngle) + TRIM_US[servo_idx];
    deltaPulse[i] = targetPulse[i] - startPulse[i];
  }
  xSemaphoreGive(x_currentPulse_mutex);

  uint32_t move_duration_ms = (override_duration > 0) ? override_duration : constrain(max_angle_delta * g_speed_factor_ms_per_degree, DURATION_MIN_MS, DURATION_MAX_MS);

  unsigned long startTime = millis();
  unsigned long currentTime;
  do
  {
    if (g_collisionDetected)
      return;
    currentTime = millis();
    float fraction = (float)(currentTime - startTime) / (float)move_duration_ms;
    if (fraction > 1.0f)
      fraction = 1.0f;
    float eased_fraction = easeInOutQuint(fraction);

    for (int i = 0; i < num_channels; i++)
    {
      uint8_t ch = channels[i];
      int pulse = startPulse[i] + (int)((float)deltaPulse[i] * eased_fraction);
      pwm.writeMicroseconds(ch, pulse);
    }
    vTaskDelay(pdMS_TO_TICKS(5));
  } while (currentTime - startTime < move_duration_ms);

  xSemaphoreTake(x_currentPulse_mutex, portMAX_DELAY);
  for (int i = 0; i < num_channels; i++)
  {
    uint8_t ch = channels[i];
    pwm.writeMicroseconds(ch, targetPulse[i]);
    currentPulse[ch] = targetPulse[i];
  }
  EEPROM.write(0, 123);
  EEPROM.put(1, currentPulse);
  EEPROM.commit();
  xSemaphoreGive(x_currentPulse_mutex);
}

void goHome(uint16_t duration)
{
  float home_pos_copy[SERVOS_NUMBER];
  for (int i = 0; i < SERVOS_NUMBER; i++)
    home_pos_copy[i] = HOME_POSITION[i];
  home_pos_copy[1] = home_pos_copy[0];
  moveServosSmoothly(SERVOS, home_pos_copy, SERVOS_NUMBER, duration);
}

// ==========================================================================
// --- ROS2 CALLBACKS ---
// ==========================================================================
void joint_command_callback(const void *msgin)
{
  const sensor_msgs__msg__JointState *msg = (const sensor_msgs__msg__JointState *)msgin;

  if (msg->position.size < 5)
  {
    return;
  }

  float targetAngles[SERVOS_NUMBER];

  targetAngles[0] = msg->position.data[0] * 180.0 / M_PI; // rad to deg
  targetAngles[1] = msg->position.data[0] * 180.0 / M_PI; // rad to deg
  targetAngles[2] = msg->position.data[1] * 180.0 / M_PI;
  targetAngles[3] = msg->position.data[2] * 180.0 / M_PI;
  targetAngles[4] = msg->position.data[3] * 180.0 / M_PI;
  targetAngles[5] = msg->position.data[4] * 180.0 / M_PI;

  moveServosSmoothly(SERVOS, targetAngles, SERVOS_NUMBER);
}

void home_service_callback(const void *req, void *res)
{
  (void)req;
  std_srvs__srv__Trigger_Response *res_in = (std_srvs__srv__Trigger_Response *)res;

  Serial.println("INFO: Home service called.");
  goHome(2500);

  res_in->success = true;
  rosidl_runtime_c__String__assign(&res_in->message, "Robot arm homed successfully.");
}

// NEW: Callback for speed factor topic
void speed_callback(const void *msgin)
{
  const std_msgs__msg__Float32 *msg = (const std_msgs__msg__Float32 *)msgin;
  if (msg->data > 0)
  {
    g_speed_factor_ms_per_degree = msg->data;
    Serial.printf("INFO: Speed factor set to %.2f ms/degree.\n", g_speed_factor_ms_per_degree);
  }
}

// NEW: Callback for collision threshold topic
void collision_callback(const void *msgin)
{
  const std_msgs__msg__Float32 *msg = (const std_msgs__msg__Float32 *)msgin;
  // Add safety checks for the threshold value
  if (msg->data >= 0.5 && msg->data <= 5.0)
  {
    g_collision_current_threshold_A = msg->data;
    Serial.printf("INFO: Collision threshold set to %.2f A.\n", g_collision_current_threshold_A);
  }
}

// ==========================================================================
// --- CORE 1: ROS Communication Task ---
// ==========================================================================
void task_ros_control(void *pvParameters)
{
  Serial.println("ROS Control Task started on Core 1.");
  for (;;)
  {
    // LATENCY FIX: Reduced timeout to check for new messages more frequently
    rclc_executor_spin_some(&executor, RCL_MS_TO_NS(10));
    // LATENCY FIX: Reduced delay to make the loop more responsive
    vTaskDelay(pdMS_TO_TICKS(1));
  }
}

// ==========================================================================
// --- CORE 0: Monitoring & Telemetry Task ---
// ==========================================================================
void task_monitoring(void *pvParameters)
{
  Serial.println("Monitoring Task started on Core 0.");
  long lastPrintTime = 0;
  long lastTelemetryTime = 0;

  for (;;)
  {
    long val = 0;
    for (int i = 0; i < nSamples; i++)
    {
      val += analogRead(ACS712_PIN);
    }
    float avg_adc = (float)val / nSamples;
    float measured_voltage = (avg_adc / adcMax) * vcc;
    g_mainCurrent_A = (measured_voltage - zero_point_voltage) / sens;

    g_gripper_current_samples[g_gripper_sample_idx] = ina219.getCurrent_mA();
    g_gripper_sample_idx = (g_gripper_sample_idx + 1) % GRIPPER_AVG_SAMPLES;
    float avg_current = 0.0;
    for (int i = 0; i < GRIPPER_AVG_SAMPLES; i++)
    {
      avg_current += g_gripper_current_samples[i];
    }
    g_gripperCurrent_mA = avg_current / GRIPPER_AVG_SAMPLES;

    if (abs(g_mainCurrent_A) > g_collision_current_threshold_A && !g_collisionDetected)
    {
      emergency_stop();
    }

    if (millis() - lastPrintTime > 1000)
    {
      Serial.printf("Status -> Main: %.3f A | Gripper: %.2f mA\n", g_mainCurrent_A, g_gripperCurrent_mA);
      lastPrintTime = millis();
    }

    // LATENCY FIX: Publish telemetry more frequently
    if (millis() - lastTelemetryTime > 50)
    {
      publish_telemetry();
      lastTelemetryTime = millis();
    }

    vTaskDelay(pdMS_TO_TICKS(50));
  }
}

void publish_telemetry()
{
  if (g_collisionDetected)
    return;

  double positions[SERVOS_NUMBER];
  xSemaphoreTake(x_currentPulse_mutex, portMAX_DELAY);
  for (int i = 0; i < SERVOS_NUMBER; i++)
  {
    float angle_deg = pulseToAngle(currentPulse[SERVOS[i]], i);
    positions[i] = angle_deg * M_PI / 180.0;
  }
  xSemaphoreGive(x_currentPulse_mutex);

  joint_state_msg.header.stamp.sec = millis() / 1000;
  joint_state_msg.header.stamp.nanosec = (millis() % 1000) * 1000000;

  joint_state_msg.position.data[0] = positions[0];
  joint_state_msg.position.data[1] = positions[2];
  joint_state_msg.position.data[2] = positions[3];
  joint_state_msg.position.data[3] = positions[4];
  joint_state_msg.position.data[4] = positions[5];

  (void)rcl_publish(&joint_state_publisher, &joint_state_msg, NULL);

  main_current_msg.data = g_mainCurrent_A;
  gripper_current_msg.data = g_gripperCurrent_mA;
  (void)rcl_publish(&main_current_publisher, &main_current_msg, NULL);
  (void)rcl_publish(&gripper_current_publisher, &gripper_current_msg, NULL);
}

// ==========================================================================
// --- SETUP ---
// ==========================================================================
void setup()
{
  delay(10);
  Serial.begin(921600);
  Serial.println("\n--- Robot Arm Firmware with ROS2 ---");

  if (!EEPROM.begin(EEPROM_SIZE))
  {
    Serial.println("FATAL: Failed to initialise EEPROM!");
    while (1)
      ;
  }
  pinMode(OE_PIN, OUTPUT);
  pinMode(ACS712_PIN, INPUT);
  digitalWrite(OE_PIN, HIGH);
  Serial.println("Step 1: Outputs DISABLED.");

  Wire.begin();
  pwm.begin();
  pwm.setOscillatorFrequency(27000000);
  pwm.setPWMFreq(PWM_FREQ);
  if (!ina219.begin())
  {
    Serial.println("FATAL: Failed to find INA219 chip!");
    while (1)
      ;
  }
  ina219.setCalibration_32V_1A();
  delay(100);
  Serial.println("Step 2: PCA9685 & INA219 initialized.");

  if (EEPROM.read(0) == 123)
  {
    Serial.println("Step 3: Found and restored last pose from EEPROM.");
    EEPROM.get(1, currentPulse);
  }
  else
  {
    Serial.println("Step 3: No EEPROM pose found. Defaulting to HOME position.");
    for (int i = 0; i < SERVOS_NUMBER; i++)
    {
      float safeAngle = HOME_POSITION[i];
      if (SERVO_INVERT[i])
        safeAngle = 180.0f - safeAngle;
      currentPulse[SERVOS[i]] = angleToPulse(safeAngle) + TRIM_US[i];
    }
  }
  digitalWrite(OE_PIN, LOW);
  Serial.println("Step 4: Outputs ENABLED. Arm is holding position.");
  delay(500);

  // --- micro-ROS Setup ---
  Serial.println("Step 5: Initializing micro-ROS agent...");

  set_microros_serial_transports(Serial);
  delay(2000);

  allocator = rcl_get_default_allocator();
  rclc_support_init(&support, 0, NULL, &allocator);
  rclc_node_init_default(&node, "robot_arm_node", "", &support);

  // --- ROS Publishers ---
  rclc_publisher_init_default(&joint_state_publisher, &node, ROSIDL_GET_MSG_TYPE_SUPPORT(sensor_msgs, msg, JointState), "joint_states");
  rclc_publisher_init_default(&main_current_publisher, &node, ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Float32), "main_current");
  rclc_publisher_init_default(&gripper_current_publisher, &node, ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Float32), "gripper_current");

  const int num_joints = 5;
  const char *joint_names[num_joints] = {"base_joint", "shoulder_joint", "elbow_joint", "wrist_joint", "gripper_joint"};

  rosidl_runtime_c__String__Sequence__init(&joint_state_msg.name, num_joints);
  for (int i = 0; i < num_joints; i++)
  {
    rosidl_runtime_c__String__assign(&joint_state_msg.name.data[i], joint_names[i]);
  }

  static double joint_positions[num_joints];
  joint_state_msg.position.data = joint_positions;
  joint_state_msg.position.size = num_joints;
  joint_state_msg.position.capacity = num_joints;

  // --- ROS Subscribers ---
  rclc_subscription_init_default(&joint_command_subscriber, &node, ROSIDL_GET_MSG_TYPE_SUPPORT(sensor_msgs, msg, JointState), "joint_commands");
  // NEW: Initialize new subscribers
  rclc_subscription_init_default(&speed_subscriber, &node, ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Float32), "speed_factor");
  rclc_subscription_init_default(&collision_subscriber, &node, ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Float32), "collision_threshold");

  static double command_positions[num_joints];
  joint_command_msg.position.data = command_positions;
  joint_command_msg.position.size = num_joints;
  joint_command_msg.position.capacity = num_joints;

  // --- ROS Services ---
  rclc_service_init_default(&home_service, &node, ROSIDL_GET_SRV_TYPE_SUPPORT(std_srvs, srv, Trigger), "home_robot");

  // --- ROS Executor ---
  // NEW: Increased handle count to 4 (3 subs + 1 srv)
  rclc_executor_init(&executor, &support.context, 4, &allocator);
  rclc_executor_add_subscription(&executor, &joint_command_subscriber, &joint_command_msg, &joint_command_callback, ON_NEW_DATA);
  // NEW: Add new subscribers to executor
  rclc_executor_add_subscription(&executor, &speed_subscriber, &speed_msg, &speed_callback, ON_NEW_DATA);
  rclc_executor_add_subscription(&executor, &collision_subscriber, &collision_msg, &collision_callback, ON_NEW_DATA);
  rclc_executor_add_service(&executor, &home_service, &home_req, &home_res, home_service_callback);

  Serial.println("Step 6: micro-ROS setup complete.");

  x_currentPulse_mutex = xSemaphoreCreateMutex();
#if AUTO_HOME_ON_BOOT
  Serial.println("Step 7: Auto slow-move to HOME from last known position.");
  goHome(4000);
#endif

  Serial.println("\n--- Initializing Dual-Core Tasks ---");
  xTaskCreatePinnedToCore(task_monitoring, "Monitoring", 4096, NULL, 1, &h_task_monitoring, 0);
  xTaskCreatePinnedToCore(task_ros_control, "ROS_Control", 8192, NULL, 1, &h_task_robot_control, 1);

  Serial.println("\n--- Initialization Complete. Ready for ROS commands. ---");
}

void loop()
{
  vTaskDelete(NULL);
}
